# WebSocket Terminal Infrastructure Analysis
Generated: 2026-01-19

## Summary

This codebase implements a dual WebSocket system for terminal streaming:
1. **Terminal I/O** - PTY streaming for tmux sessions and Docker containers
2. **Live Events** - Real-time state updates (sessions, host info, Docker)

Both use binary-efficient protocols with flow control, latency optimization, and reconnection logic.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│  Mobile App (React Native + Expo)                               │
│  ┌───────────────────┐         ┌──────────────────────┐        │
│  │ Terminal WebView  │         │  Live State Hook     │        │
│  │ (xterm.js)        │         │  (useHostsLive)      │        │
│  └─────────┬─────────┘         └──────────┬───────────┘        │
│            │                               │                     │
└────────────┼───────────────────────────────┼─────────────────────┘
             │ WebSocket                     │ WebSocket
             │ /ws or /docker/exec           │ /events
             ↓                               ↓
┌─────────────────────────────────────────────────────────────────┐
│  Agent Server (Node.js + Hono + ws library)                     │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ agent/src/http/ws.ts - WebSocket Handler                    ││
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐           ││
│  │  │ termWss    │  │ dockerWss  │  │ eventsWss  │           ││
│  │  │ /ws        │  │ /docker/   │  │ /events    │           ││
│  │  │            │  │ exec       │  │            │           ││
│  │  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘           ││
│  └────────┼───────────────┼───────────────┼──────────────────┘│
│           │               │               │                     │
│           ↓               ↓               ↓                     │
│  ┌────────────────┐ ┌────────────┐ ┌──────────────────┐       │
│  │ node-pty       │ │ node-pty   │ │ Polling timer    │       │
│  │ tmux attach    │ │ docker exec│ │ (200ms default)  │       │
│  └────────┬───────┘ └─────┬──────┘ └─────┬────────────┘       │
└───────────┼───────────────┼──────────────┼──────────────────────┘
            ↓               ↓              ↓
      tmux session    Docker container   API calls
                                          (sessions, host, docker)
```

---

## 1. Mobile App WebSocket Connections

### Location
- **Tmux terminal:** `/home/gabrielolv/Documents/Projects/ter/app/session/[hostId]/[name]/terminal.tsx`
- **Docker terminal:** `/home/gabrielolv/Documents/Projects/ter/app/hosts/[id]/docker/[containerId]/terminal.tsx`
- **Live events hook:** `/home/gabrielolv/Documents/Projects/ter/lib/live.tsx`

### Connection Pattern

Both terminal screens use the same pattern:

```typescript
// Build WebSocket URL
const wsUrl = useMemo(() => {
  const base = new URL(host.baseUrl);
  const protocol = base.protocol === 'https:' ? 'wss:' : 'ws:';
  const params = new URLSearchParams();
  params.set('session', sessionName); // or 'container' for Docker
  params.set('cols', '80');
  params.set('rows', '24');
  if (host.authToken) params.set('token', host.authToken);
  return `${protocol}//${base.host}/ws?${params}`;
}, [host, sessionName]);

// Embedded in HTML for xterm.js WebView
const socket = new WebSocket(wsUrl);
```

### Terminal HTML Injection

**Key File:** Both terminal screens inject identical xterm.js HTML with WebSocket client code

**Pattern:** Build HTML string → Cache by version → Inject into WebView

```typescript
const TERMINAL_HTML_VERSION = 'probe-v3';

function buildTerminalHtml(wsUrl: string, theme: ThemeColors): string {
  return `<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
  </head>
  <body>
    <div id="terminal"></div>
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script>
      const term = new Terminal({ ... });
      const socket = new WebSocket('${wsUrl}');
      
      socket.onmessage = (event) => {
        term.write(event.data); // PTY → Terminal
      };
      
      term.onData((data) => {
        socket.send(JSON.stringify({ type: 'input', data })); // Input → PTY
      });
    </script>
  </body>
</html>`;
}
```

### Live Events Connection

**Location:** `/home/gabrielolv/Documents/Projects/ter/lib/live.tsx`

```typescript
export function useHostsLive(hosts: Host[], options: LiveOptions) {
  // Build /events WebSocket URL
  const url = buildEventsUrl(host, options);
  // wss://host:4020/events?sessions=1&preview=1&insights=1&host=1&docker=1&interval=200
  
  const socket = new WebSocket(url);
  
  socket.onmessage = (event) => {
    const payload = JSON.parse(event.data);
    if (payload.type === 'snapshot') {
      updateState(host.id, {
        sessions: payload.sessions,
        hostInfo: payload.host,
        docker: payload.docker,
      });
    }
  };
  
  // Reconnection logic with exponential backoff
  socket.onclose = () => {
    const delay = Math.min(10000, 1000 * Math.pow(2, reconnects));
    setTimeout(() => connectHost(host), delay);
  };
}
```

---

## 2. Agent Server WebSocket Handling

### Location
**Main file:** `/home/gabrielolv/Documents/Projects/ter/agent/src/http/ws.ts` (319 lines)

### Three WebSocket Servers

```typescript
export function attachWebSocketServers(server: Server) {
  const termWss = new WebSocketServer({ noServer: true, perMessageDeflate: false });
  const dockerWss = new WebSocketServer({ noServer: true, perMessageDeflate: false });
  const eventsWss = new WebSocketServer({ noServer: true, perMessageDeflate: false });
  
  const wssByPath = new Map([
    ['/ws', termWss],           // Tmux sessions
    ['/events', eventsWss],     // Live state updates
    ['/docker/exec', dockerWss], // Docker containers
  ]);
}
```

### Authentication & Upgrade Handling

```typescript
server.on('upgrade', (req: IncomingMessage, socket: Socket, head: Buffer) => {
  const url = new URL(req.url || '/', `http://${req.headers.host}`);
  const wss = wssByPath.get(url.pathname);
  
  // Token auth (optional)
  if (TOKEN) {
    const token = url.searchParams.get('token') || '';
    if (token !== TOKEN) {
      socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n');
      socket.destroy();
      return;
    }
  }
  
  wss.handleUpgrade(req, socket, head, (ws) => {
    wss.emit('connection', ws, req);
  });
});
```

### Tmux Terminal Handler (`/ws`)

**Lines:** 217-247 in ws.ts

```typescript
termWss.on('connection', async (ws: WebSocket, req: IncomingMessage) => {
  enableLowLatencySocket(ws); // TCP_NODELAY
  
  const url = new URL(req.url || '/', `http://${req.headers.host}`);
  const session = url.searchParams.get('session');
  const cols = parseDimension(url.searchParams.get('cols'), 80);
  const rows = parseDimension(url.searchParams.get('rows'), 24);
  const createIfMissing = url.searchParams.get('create') === '1';
  
  // Check if session exists (unless create=1)
  if (!createIfMissing) {
    try {
      await runTmux(['has-session', '-t', session]);
    } catch {
      ws.close(1008, 'session not found');
      return;
    }
  }
  
  // Spawn PTY wrapping tmux
  const term = pty.spawn(
    'tmux',
    ['new-session', '-A', '-s', session, '-x', String(cols), '-y', String(rows)],
    {
      name: 'xterm-256color',
      cols,
      rows,
      cwd: process.env.HOME,
      env: { TERM: 'xterm-256color', COLORTERM: 'truecolor' },
    }
  );
  
  // Disable tmux status bar
  runTmux(['set-option', '-t', session, 'status', 'off']).catch(() => {});
  
  // Bridge WebSocket ↔ PTY
  attachPtyBridge(ws, term, 'session ended');
});
```

### Docker Terminal Handler (`/docker/exec`)

**Lines:** 249-274 in ws.ts

```typescript
dockerWss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
  enableLowLatencySocket(ws);
  
  const url = new URL(req.url || '/', `http://${req.headers.host}`);
  const container = url.searchParams.get('container');
  const cols = parseDimension(url.searchParams.get('cols'), 80);
  const rows = parseDimension(url.searchParams.get('rows'), 24);
  const shell = url.searchParams.get('shell') || 'sh';
  
  // Spawn PTY wrapping docker exec
  const term = pty.spawn('docker', ['exec', '-it', container, shell], {
    name: 'xterm-256color',
    cols,
    rows,
    cwd: process.env.HOME,
    env: { TERM: 'xterm-256color', COLORTERM: 'truecolor' },
  });
  
  attachPtyBridge(ws, term, 'exec ended');
});
```

### Live Events Handler (`/events`)

**Lines:** 276-319 in ws.ts

```typescript
eventsWss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
  const url = new URL(req.url || '/', `http://${req.headers.host}`);
  const config = parseLiveConfig(url); // Parse ?sessions=1&host=1&docker=1&interval=200
  
  let lastPayload = '';
  let refreshTimer: ReturnType<typeof setTimeout> | null = null;
  
  const sendSnapshot = async () => {
    try {
      const snapshot = await getLiveSnapshot(config);
      const payload = JSON.stringify(snapshot);
      
      // Only send if changed
      if (payload !== lastPayload && ws.readyState === WebSocket.OPEN) {
        ws.send(payload);
        lastPayload = payload;
      }
    } catch (err) {
      ws.send(JSON.stringify({ type: 'error', message: err.message }));
    }
  };
  
  // Send initial snapshot
  sendSnapshot();
  
  // Poll at configured interval (default 200ms)
  const interval = setInterval(sendSnapshot, config.intervalMs);
  
  // Handle client refresh requests
  ws.on('message', (data: RawData) => {
    const payload = JSON.parse(data.toString());
    if (payload.type === 'refresh' || payload.type === 'ping') {
      // Debounced refresh (200ms)
      if (!refreshTimer) {
        refreshTimer = setTimeout(() => {
          refreshTimer = null;
          sendSnapshot();
        }, 200);
      }
    }
  });
  
  ws.on('close', () => {
    clearInterval(interval);
    if (refreshTimer) clearTimeout(refreshTimer);
  });
});
```

---

## 3. Message Protocol

### Terminal I/O Protocol (Binary + JSON)

**Client → Server Messages:**

```typescript
type TmuxInputPayload = {
  type: 'input';
  data: string; // Raw keyboard input (e.g., "ls\n" or "\u0003" for Ctrl+C)
};

type TmuxResizePayload = {
  type: 'resize';
  cols: number;
  rows: number;
};

type TmuxProbePayload = {
  type: 'probe';
  id: number; // Round-trip latency measurement
};

type TmuxAckPayload = {
  type: 'ack';
  bytes: number; // Acknowledge bytes received (flow control)
};
```

**Server → Client Messages:**

```typescript
// 1. Raw PTY output (no JSON wrapping)
ws.send(terminalOutputString); // ANSI escape sequences, text, etc.

// 2. Probe response (embedded in terminal stream)
const response = `\u0001TERPROBE:${JSON.stringify({ id: probeId, serverTime: Date.now() })}\u0002`;
ws.send(response);
```

**Key Design Decision:** Server sends raw terminal data (not JSON-wrapped) for efficiency. Only control messages use JSON.

### Live Events Protocol

**Server → Client:**

```typescript
type LiveSnapshotMessage = {
  type: 'snapshot';
  ts?: number;
  sessions?: Session[];
  host?: HostInfo;
  docker?: DockerSnapshot;
};

type LiveErrorMessage = {
  type: 'error';
  message?: string;
};
```

**Client → Server:**

```typescript
type RefreshRequest = {
  type: 'refresh'; // Force immediate snapshot
};

type PingRequest = {
  type: 'ping'; // Keep-alive
};
```

---

## 4. Flow Control & Performance Optimization

### TCP Latency Optimization

**Lines:** 64-68 in ws.ts

```typescript
function enableLowLatencySocket(ws: WebSocket) {
  const socket = (ws as unknown as { _socket?: { setNoDelay?: (noDelay: boolean) => void } })._socket;
  socket?.setNoDelay?.(true); // Disable Nagle's algorithm for low latency
}
```

Called for all WebSocket connections (terminal and events).

### Backpressure Flow Control

**Lines:** 71-169 in ws.ts

**Problem:** PTY can produce output faster than WebSocket can send, causing memory bloat.

**Solution:** Track in-flight bytes, queue excess data, pause PTY when queue fills.

```typescript
const FLOW_HIGH_WATERMARK = 128 * 1024; // 128KB - pause PTY above this
const FLOW_LOW_WATERMARK = 64 * 1024;   // 64KB - resume PTY below this

function attachPtyBridge(ws: WebSocket, term: IPty, closeMessage: string) {
  let inFlightBytes = 0; // Bytes sent but not acknowledged
  let queuedBytes = 0;   // Bytes waiting to send
  let queue: string[] = [];
  let isPaused = false;
  
  const maybePause = () => {
    if (isPaused) return;
    if (typeof term.pause === 'function') {
      term.pause(); // Stop reading from PTY
      isPaused = true;
    }
  };
  
  const maybeResume = () => {
    if (!isPaused) return;
    if (typeof term.resume === 'function') {
      term.resume(); // Resume reading from PTY
      isPaused = false;
    }
  };
  
  const sendOrQueue = (data: string) => {
    if (inFlightBytes >= FLOW_HIGH_WATERMARK) {
      queue.push(data);
      queuedBytes += data.length;
      maybePause(); // Pause PTY to prevent memory bloat
      return;
    }
    ws.send(data);
    inFlightBytes += data.length;
  };
  
  // PTY output → WebSocket
  term.onData((data) => {
    sendOrQueue(data);
  });
  
  // Client acknowledges bytes received
  ws.on('message', (data) => {
    const payload = parseClientPayload(data.toString());
    if (payload?.type === 'ack') {
      inFlightBytes = Math.max(0, inFlightBytes - payload.bytes);
      flushQueue(); // Try to send queued data
    }
  });
  
  const flushQueue = () => {
    while (queue.length > 0 && inFlightBytes <= FLOW_LOW_WATERMARK) {
      const chunk = queue.shift();
      ws.send(chunk);
      inFlightBytes += chunk.length;
    }
    if (queue.length === 0) {
      maybeResume(); // Resume PTY when queue is empty
    }
  };
}
```

### Client-Side Batching (xterm.js)

**Location:** Embedded in terminal HTML (both terminal screens)

```javascript
// Client batches output to avoid blocking xterm.js rendering
let outputBuffer = '';
let outputScheduled = false;

function queueOutput(data) {
  outputBuffer += data;
  if (outputScheduled) return;
  outputScheduled = true;
  queueMicrotask(() => {
    outputScheduled = false;
    const chunk = outputBuffer;
    outputBuffer = '';
    term.write(chunk, () => {
      // Acknowledge bytes after rendering
      if (socket?.readyState === 1) {
        socket.send(JSON.stringify({ type: 'ack', bytes: chunk.length }));
      }
    });
  });
}

socket.onmessage = (event) => {
  queueOutput(event.data);
};
```

**Why microtask?** Batches multiple socket messages in one xterm.js render cycle.

### Client-Side Input Batching

```javascript
// Client batches input to reduce WebSocket messages
let inputBuffer = '';
let inputScheduled = false;

function queueInput(data) {
  // Fast path: send single chars immediately if buffer empty
  if (socket?.readyState === 1 && data.length <= 1 && !inputScheduled && !inputBuffer) {
    socket.send(JSON.stringify({ type: 'input', data }));
    return;
  }
  
  // Batch multi-char input (paste)
  inputBuffer += data;
  if (inputScheduled) return;
  inputScheduled = true;
  queueMicrotask(() => {
    inputScheduled = false;
    const chunk = inputBuffer;
    inputBuffer = '';
    socket.send(JSON.stringify({ type: 'input', data: chunk }));
  });
}

term.onData((data) => {
  queueInput(data);
});
```

---

## 5. Terminal Lifecycle

### Connection Setup

```
1. Mobile app builds WebSocket URL with session/container + dimensions
2. React Native renders WebView with HTML containing xterm.js + WebSocket client
3. WebView loads → xterm.js initializes → WebSocket connects
4. Server authenticates (token check)
5. Server spawns PTY (tmux attach or docker exec)
6. PTY output streams → WebSocket → xterm.js renders
```

### Resize Handling

```
Client (xterm.js)                    Server (PTY)
─────────────────                    ────────────
Window resize
  ↓
FitAddon.fit()
  ↓
term.cols/rows updated
  ↓
socket.send({ type: 'resize', cols, rows })
                                  →  term.resize(cols, rows)
                                  →  PTY updates dimensions
                                  →  tmux/docker adjusts layout
```

### Cleanup & Termination

**When WebSocket closes:**

```typescript
ws.on('close', cleanup);

const cleanup = () => {
  termClosed = true;
  queue = [];
  queuedBytes = 0;
  inFlightBytes = 0;
  term.kill(); // Kill PTY wrapper
};
```

**Important:** 
- **Tmux sessions:** PTY dies but tmux session persists (can reconnect)
- **Docker containers:** PTY dies but container keeps running

**When PTY exits:**

```typescript
term.onExit(() => {
  termClosed = true;
  if (ws.readyState === WebSocket.OPEN) {
    ws.close(1000, closeMessage); // "session ended" or "exec ended"
  }
  cleanup();
});
```

---

## 6. Live Events System

### Purpose
Provides real-time state updates without terminal I/O overhead.

### Query Parameters

```
wss://host:4020/events?sessions=1&preview=1&insights=1&host=1&docker=1&interval=200&token=xxx
```

| Parameter | Effect |
|-----------|--------|
| `sessions=1` | Include session list |
| `preview=1` | Include terminal preview (last N lines) |
| `previewLines=N` | Preview line count (default varies) |
| `insights=1` | Include agent detection, git status, etc. |
| `host=1` | Include host CPU, memory, uptime |
| `docker=1` | Include Docker container list + stats |
| `interval=N` | Poll interval in ms (default 200ms) |
| `token=xxx` | Auth token |

### Snapshot Structure

**Location:** `/home/gabrielolv/Documents/Projects/ter/agent/src/http/live.ts`

```typescript
type LiveSnapshot = {
  type: 'snapshot';
  ts: number; // Server timestamp
  sessions?: Session[];
  host?: HostInfo;
  docker?: DockerSnapshot;
};
```

### Update Frequency

- **Default:** 200ms polling
- **On-demand:** Client sends `{ type: 'refresh' }` → debounced 200ms response
- **Change detection:** Server only sends if JSON changed from last snapshot

### Reconnection Logic

**Location:** `/home/gabrielolv/Documents/Projects/ter/lib/live.tsx` (lines 225-236)

```typescript
socket.onclose = () => {
  updateState(host.id, { status: 'offline' });
  
  // Exponential backoff: 1s, 2s, 4s, 8s, max 10s
  const delay = Math.min(10000, 1000 * Math.pow(2, reconnects));
  reconnects += 1;
  
  setTimeout(() => {
    connectHost(host); // Retry
  }, delay);
};
```

### Health Probing

When WebSocket fails to get initial snapshot, probe via HTTP to determine error:

```typescript
const startErrorProbe = () => {
  const result = await probeHealth(host.baseUrl, host.authToken, 2500);
  const message = formatProbeError(host.baseUrl, result);
  updateState(host.id, { status: 'offline', error: message });
};
```

**Possible errors:**
- "Agent requires token" (401)
- "No agent detected on port 4020" (404/invalid response)
- "Host unreachable" (network error)
- "Connection failed (statusCode)" (other HTTP errors)

---

## 7. Key Files & Entry Points

| File | Purpose | Key Functions |
|------|---------|---------------|
| `/home/gabrielolv/Documents/Projects/ter/agent/src/http/ws.ts` | WebSocket server handlers | `attachWebSocketServers()`, `attachPtyBridge()` |
| `/home/gabrielolv/Documents/Projects/ter/agent/src/server.ts` | HTTP server setup | `startServer()`, calls `attachWebSocketServers()` |
| `/home/gabrielolv/Documents/Projects/ter/app/session/[hostId]/[name]/terminal.tsx` | Tmux terminal UI | `buildTerminalHtml()`, WebView message bridge |
| `/home/gabrielolv/Documents/Projects/ter/app/hosts/[id]/docker/[containerId]/terminal.tsx` | Docker terminal UI | `buildDockerWsUrl()`, `buildTerminalHtml()` |
| `/home/gabrielolv/Documents/Projects/ter/lib/live.tsx` | Live events hook | `useHostsLive()`, `useHostLive()` |
| `/home/gabrielolv/Documents/Projects/ter/agent/src/http/live.ts` | Live snapshot builder | `getLiveSnapshot()`, `parseLiveConfig()` |

---

## 8. WebSocket URL Patterns

### Terminal I/O

**Tmux sessions:**
```
ws://localhost:4020/ws?session=my-session&cols=80&rows=24&token=xxx
```

**Docker containers:**
```
ws://localhost:4020/docker/exec?container=abc123&shell=sh&cols=80&rows=24&token=xxx
```

### Live Events

```
ws://localhost:4020/events?sessions=1&preview=1&insights=1&host=1&docker=1&interval=200&token=xxx
```

---

## 9. Performance Characteristics

### Latency Optimization
- **TCP_NODELAY:** Disabled Nagle's algorithm for all WebSocket connections
- **Binary frames:** Raw PTY output (no JSON overhead)
- **Microtask batching:** Client batches output/input to reduce message count
- **Probe/ack protocol:** Measures round-trip time for latency monitoring

### Flow Control
- **Server-side:** Pause PTY when WebSocket buffer fills (128KB threshold)
- **Client-side:** Acknowledge bytes after rendering to signal readiness
- **Queuing:** In-memory queue prevents data loss during backpressure

### Live Events Efficiency
- **Change detection:** Only send snapshots when state changes
- **Configurable polling:** Default 200ms, adjustable per client
- **Debounced refresh:** Client-requested refreshes debounced to 200ms

---

## 10. Error Handling & Edge Cases

### WebSocket Connection Failures

**Terminal I/O:**
- Session not found → Close with code 1008, reason "session not found"
- Missing container → Close with code 1008, reason "container required"
- PTY spawn failed → Close with code 1011, reason from error

**Live Events:**
- Snapshot fetch error → Send `{ type: 'error', message: '...' }`
- Invalid client message → Silently ignore

### PTY Lifecycle Edge Cases

**Server tracks:**
- `termClosed` - PTY has exited
- `cleanedUp` - Cleanup already ran (prevent double-free)

**Cleanup on:**
- WebSocket close
- WebSocket error
- PTY exit

**Idempotent cleanup:**
```typescript
const cleanup = () => {
  if (cleanedUp) return;
  cleanedUp = true;
  termClosed = true;
  queue = [];
  try { term.kill(); } catch {}
};
```

### Reconnection Strategy

**Live events:**
- Exponential backoff: 1s → 2s → 4s → 8s → 10s (max)
- Health probe on failure to provide user-friendly error
- Resume from last known state (cached in liveStateCache)

**Terminal I/O:**
- No automatic reconnection (user must navigate back)
- Tmux sessions persist (can reconnect via new WebSocket)
- Docker exec dies with WebSocket (ephemeral)

---

## 11. Special Features

### Touch Selection (Long Press)

**Location:** Docker terminal HTML (lines 200-260)

```javascript
// Long-press detection (400ms)
document.addEventListener('touchstart', (e) => {
  touchStartTime = Date.now();
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});

document.addEventListener('touchmove', (e) => {
  const elapsed = Date.now() - touchStartTime;
  const moved = Math.abs(dx) > MOVE_THRESHOLD || Math.abs(dy) > MOVE_THRESHOLD;
  
  if (!moved && elapsed > 400) {
    isSelectionMode = true;
    // Convert touch coordinates to terminal cell position
    const start = touchToCell(touchStartX, touchStartY);
    term.select(start.col, start.row, 1);
    sendToRN({ type: 'haptic' }); // Trigger haptic feedback
  }
  
  if (isSelectionMode) {
    // Extend selection as finger moves
    const end = touchToCell(x, y);
    term.select(startCol, startRow, length);
  }
});
```

### Copy to Clipboard

**Two modes:**
1. **Selection copy:** Copy selected text
2. **Viewport copy:** Copy visible screen if no selection

```javascript
window.__copySelection = () => {
  const text = term.getSelection();
  if (text && text.trim().length > 0) {
    sendToRN({ type: 'copy', text }); // Copy selection
    return;
  }
  
  // Copy viewport
  const buffer = term.buffer.active;
  const lines = [];
  for (let i = buffer.viewportY; i < buffer.viewportY + term.rows; i++) {
    const line = buffer.getLine(i);
    if (line) lines.push(line.translateToString(true));
  }
  sendToRN({ type: 'copy', text: lines.join('\n') });
};
```

**React Native side:**
```typescript
onMessage={async (event) => {
  const payload = JSON.parse(event.nativeEvent.data);
  if (payload?.type === 'copy') {
    await Clipboard.setStringAsync(payload.text);
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
  }
}}
```

### Ctrl+C Button

**Location:** Both terminal screens have OctagonX icon button

```typescript
<Pressable
  onPress={() => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    webRef.current?.injectJavaScript('window.__sendCtrlC && window.__sendCtrlC(); true;');
  }}
>
  <OctagonX size={16} color={colors.red} />
</Pressable>
```

**WebView side:**
```javascript
window.__sendCtrlC = () => {
  if (socket?.readyState === 1) {
    socket.send(JSON.stringify({ type: 'input', data: '\u0003' })); // ASCII ETX
  }
};
```

---

## 12. Shared Types & Contracts

### Terminal Message Types (Server)

**Location:** `/home/gabrielolv/Documents/Projects/ter/agent/src/http/ws.ts` (lines 6-27)

```typescript
type TmuxInputPayload = { type: 'input'; data: string };
type TmuxResizePayload = { type: 'resize'; cols: number; rows: number };
type TmuxProbePayload = { type: 'probe'; id: number };
type TmuxAckPayload = { type: 'ack'; bytes: number };
type TmuxClientPayload = TmuxInputPayload | TmuxResizePayload | TmuxProbePayload | TmuxAckPayload;
```

### Live Events Types

**Location:** `/home/gabrielolv/Documents/Projects/ter/lib/live.tsx` (lines 13-38)

```typescript
type LiveSnapshotMessage = {
  type: 'snapshot';
  ts?: number;
  sessions?: Session[];
  host?: HostInfo;
  docker?: DockerSnapshot;
};

type LiveErrorMessage = {
  type: 'error';
  message?: string;
};
```

### Shared Domain Types

**Location:** `/home/gabrielolv/Documents/Projects/ter/lib/types.ts` (imported by both app and agent)

```typescript
type Session = { ... };
type HostInfo = { ... };
type DockerSnapshot = { ... };
type Host = { id: string; baseUrl: string; authToken?: string; ... };
```

---

## Summary Table

| Component | WebSocket Path | Message Format | Purpose |
|-----------|----------------|----------------|---------|
| **Tmux Terminal** | `/ws?session=X&cols=80&rows=24` | Client: JSON payloads<br>Server: Raw PTY output | Full terminal I/O for tmux sessions |
| **Docker Terminal** | `/docker/exec?container=X&shell=sh&cols=80&rows=24` | Client: JSON payloads<br>Server: Raw PTY output | Full terminal I/O for Docker containers |
| **Live Events** | `/events?sessions=1&host=1&docker=1&interval=200` | Both: JSON payloads | Real-time state updates (sessions, host, Docker) |

---

## Open Questions

1. **Probe protocol usage:** The probe/ack infrastructure exists but is it actively used for latency monitoring? (No client-side probe sending observed)
2. **Live events caching:** liveStateCache persists across reconnects - is there a cleanup strategy for stale hosts?
3. **Docker exec shell detection:** Currently defaults to 'sh' - could detect based on container image?
4. **Flow control tuning:** 128KB/64KB watermarks - are these optimal for mobile networks?
5. **WebSocket compression:** Currently disabled (`perMessageDeflate: false`) - intentional for latency?

---

## Conventions Discovered

### WebSocket Patterns
- **No compression:** All WebSocket servers use `perMessageDeflate: false`
- **Low latency:** All connections set `TCP_NODELAY`
- **Token auth:** Optional `?token=xxx` query param for all endpoints
- **Graceful close:** Always provide close code (1000, 1008, 1011) and reason string

### Terminal Streaming
- **Binary efficiency:** Raw PTY output (no JSON wrapping)
- **Flow control:** Client acknowledges bytes after rendering
- **Batching:** Both input and output batched via microtasks
- **Probe markers:** Use ASCII control chars (`\u0001`, `\u0002`) to embed metadata

### Code Organization
- **Single file for WS:** All WebSocket logic in `agent/src/http/ws.ts`
- **Shared HTML:** Both terminal screens use identical xterm.js HTML pattern
- **Hook-based state:** Live events use React hook pattern (`useHostsLive`)
- **Caching strategy:** Source HTML cached by version + theme key
