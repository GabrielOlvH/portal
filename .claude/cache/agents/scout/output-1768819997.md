# Terminal UI Component Analysis
Generated: 2026-01-19

## Summary

The terminal component is a sophisticated React Native implementation that uses WebView to run xterm.js for terminal emulation. It features:
- Multi-session support with swipeable paging
- Expandable keyboard accessory bar with helper keys
- Touch-based text selection with haptic feedback
- WebSocket-based terminal communication
- Image upload capability
- Snippet integration for quick commands

## Architecture Overview

```
SessionTerminalScreen (React Native)
    â”‚
    â”œâ”€â”€â”€ WebView (per session)
    â”‚     â””â”€â”€â”€ xterm.js + WebSocket
    â”‚
    â”œâ”€â”€â”€ Header (floating controls)
    â”‚     â”œâ”€â”€â”€ Back button
    â”‚     â”œâ”€â”€â”€ Copy button
    â”‚     â””â”€â”€â”€ Ctrl+C (kill) button
    â”‚
    â”œâ”€â”€â”€ Pager (swipeable sessions)
    â”‚     â””â”€â”€â”€ Animated horizontal scroll
    â”‚
    â””â”€â”€â”€ Keyboard Accessory Bar
          â”œâ”€â”€â”€ Main row (Esc, Tab, arrows, Done)
          â””â”€â”€â”€ Expanded row (Paste, Image, PgUp/Dn, Snippets)
```

## File Structure

### Main Component
**Location:** `/home/gabrielolv/Documents/Projects/ter/app/session/[hostId]/[name]/terminal.tsx`
- **Lines:** 1,124 total
- **Main Export:** `SessionTerminalScreen` component (line 487)

### Key Functions

| Function | Line | Purpose |
|----------|------|---------|
| `buildWsUrl` | 105 | Constructs WebSocket URL from host config |
| `buildTerminalHtml` | 116 | Generates HTML with embedded xterm.js |
| `SessionTerminalScreen` | 487 | Main component |
| `withAlpha` | 998 | Converts hex color to rgba with alpha |
| `createStyles` | 1007 | Creates theme-aware styles |

## Component Architecture

### 1. Terminal View Structure

The component uses a **paged architecture** for multi-session support:

```typescript
// Lines 693-694: Animation state for paging
const offsetX = useSharedValue(initialIndex >= 0 ? -initialIndex * screenWidth : 0);
const currentIndexShared = useSharedValue(initialIndex >= 0 ? initialIndex : 0);

// Lines 718-751: Pan gesture for swiping between sessions
const panGesture = Gesture.Pan()
  .enabled(!isSelecting)
  .maxPointers(1)
  .activeOffsetX([-15, 15])
  .failOffsetY([-10, 10])
  // ... gesture handlers
```

**Key Features:**
- Cumulative offset tracking (never resets between swipes)
- Rubber band effect at edges (lines 728-729)
- 30% threshold for switching sessions (line 734)
- Haptic feedback on session switch (lines 740, 743)

### 2. Keyboard Accessory Implementation

Located at **lines 911-993**, the keyboard accessory has two states:

#### Collapsed State (lines 921-941)
```typescript
mainHelperKeys = [
  { label: 'Esc', data: '\u001b' },
  { label: 'Tab', data: '\t' },
  { label: 'Up', data: '\u001b[A', icon: ChevronUp },
  { label: 'Down', data: '\u001b[B', icon: ChevronDown },
  { label: 'Left', data: '\u001b[D', icon: ChevronLeft },
  { label: 'Right', data: '\u001b[C', icon: ChevronRight },
]
```

Shows:
- Done button (ChevronDown icon) - dismisses keyboard
- Main helper keys (Esc, Tab, arrows)
- Expand button (MoreHorizontal icon)

#### Expanded State (lines 943-990)
```typescript
expandedHelperKeys = [
  { label: 'PgUp', data: '\u001b[5~' },
  { label: 'PgDn', data: '\u001b[6~' },
]
```

Shows additional row with:
- Paste button (ClipboardPaste icon)
- Image upload button (ImageIcon)
- PgUp/PgDn keys
- User-defined snippets (from snippets store)

**State Management:**
```typescript
// Line 502
const [isAccessoryExpanded, setIsAccessoryExpanded] = useState(false);

// Lines 577-579, 585-586: Auto-collapse on blur
useEffect(() => {
  if (!isFocused) {
    setIsAccessoryExpanded(false);
  }
}, [isFocused]);
```

### 3. Text Selection & Copy

Text selection uses **long-press detection** within the WebView HTML:

#### WebView Implementation (lines 366-473)

```javascript
// Lines 376-377: Touch state
const LONG_PRESS_DURATION = 400;
const MOVE_THRESHOLD = 10;

// Lines 418-428: Selection mode activation
if (!isSelectionMode && !moved && elapsed > LONG_PRESS_DURATION) {
  isSelectionMode = true;
  const start = touchToCell(touchStartX, touchStartY);
  selectionStartCol = start.col;
  selectionStartRow = start.row;
  term.select(selectionStartCol, selectionStartRow + term.buffer.active.viewportY, 1);
  sendToRN({ type: 'selectionStart' });
  sendToRN({ type: 'haptic' });
}
```

**Selection Flow:**
1. User long-presses on terminal (400ms threshold)
2. WebView sends `selectionStart` message to React Native
3. React Native sets `isSelecting` state to disable pan gesture
4. User drags to extend selection
5. Selection calculations handle:
   - Single-line selections (line 436-439)
   - Multi-line forward selections (lines 440-441)
   - Multi-line backward selections (lines 442-444)

#### Copy Implementation (lines 289-303)

```javascript
window.__copySelection = () => {
  const text = term.getSelection();
  if (text && text.trim().length > 0) {
    sendToRN({ type: 'copy', text });
    return;
  }
  // Fallback: copy visible viewport
  const buffer = term.buffer.active;
  const start = buffer.viewportY;
  const lines = [];
  for (let i = start; i < Math.min(buffer.length, start + term.rows); i += 1) {
    const line = buffer.getLine(i);
    if (line) lines.push(line.translateToString(true));
  }
  sendToRN({ type: 'copy', text: lines.join('\n') });
};
```

**Copy button handler (lines 815-820):**
```typescript
<Pressable
  onPress={() => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    copyFromTerminal();
  }}
>
  <Copy size={16} color={colors.terminalForeground} />
</Pressable>
```

**React Native handler (lines 875-880):**
```typescript
case 'copy': {
  if (typeof payload.text !== 'string' || !payload.text) return;
  await Clipboard.setStringAsync(payload.text);
  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
  return;
}
```

### 4. WebView Communication

**React Native â†’ WebView:**
```typescript
// Line 603-608: Send terminal input
const sendToTerminal = useCallback((data: string) => {
  const payload = JSON.stringify(data);
  webRefs.current[currentSessionName]?.injectJavaScript(
    `window.__sendToTerminal && window.__sendToTerminal(${payload}); true;`
  );
}, [currentSessionName]);
```

**WebView â†’ React Native (lines 866-902):**
```typescript
onMessage={async (event) => {
  const payload = JSON.parse(event.nativeEvent.data);
  switch (payload.type) {
    case 'copy': // Handle copy
    case 'haptic': // Trigger haptic feedback
    case 'selectionStart': // Disable pan gesture
    case 'selectionEnd': // Enable pan gesture
    case 'status': // Connection status
    case 'sessionEnded': // Navigate back
  }
}}
```

## Terminal HTML Structure

**Generated HTML (lines 116-485):**

```html
<!doctype html>
<html>
  <head>
    <!-- xterm.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <style>
      /* Prevent user selection on overlay to allow custom touch handling */
      #terminal, #overlay {
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
    </style>
  </head>
  <body>
    <div id="terminal"></div>
    <div id="overlay"></div> <!-- Touch event layer -->
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script>
      // Terminal initialization
      // WebSocket connection
      // Touch handling for selection and scroll
    </script>
  </body>
</html>
```

### WebSocket Protocol (lines 251-277)

**Message Types:**

| Direction | Type | Data | Purpose |
|-----------|------|------|---------|
| WS â†’ Terminal | (raw string) | Terminal output | Display output |
| Terminal â†’ WS | `input` | `{ type: 'input', data: string }` | Send user input |
| Terminal â†’ WS | `resize` | `{ type: 'resize', cols: number, rows: number }` | Notify terminal size |
| Terminal â†’ WS | `ack` | `{ type: 'ack', bytes: number }` | Flow control |

**Connection handling:**
- Auto-reconnect on disconnect (1 second delay)
- No reconnect if session ended or not found (lines 270-273)
- Connection status sent to React Native (lines 254, 267, 276)

### Performance Optimizations

**1. Microtask Batching (lines 169-220)**
```javascript
// Buffer multiple input/output operations into single WebSocket sends
let outputBuffer = '';
let outputScheduled = false;

function queueOutput(data) {
  outputBuffer += data;
  if (outputScheduled) return;
  outputScheduled = true;
  scheduleMicrotask(() => {
    outputScheduled = false;
    flushOutput();
  });
}
```

**2. Source Caching (lines 505, 527-543)**
```typescript
const sourceCache = useRef<Record<string, SourceCacheEntry>>({});

const getSourceForSession = useCallback((sessionName: string) => {
  const cacheKey = `${wsUrl}|${themeKey}|${TERMINAL_HTML_VERSION}`;
  const cached = sourceCache.current[sessionName];
  if (!cached || cached.key !== cacheKey) {
    sourceCache.current[sessionName] = {
      key: cacheKey,
      source: { html: buildTerminalHtml(wsUrl, terminalTheme) },
    };
  }
  return sourceCache.current[sessionName]?.source;
}, [host, terminalTheme, themeKey]);
```

**3. Fit Scheduling (lines 240-249)**
```javascript
function scheduleFit() {
  if (fitScheduled) return;
  fitScheduled = true;
  requestAnimationFrame(() => {
    fitScheduled = false;
    fitAddon.fit();
    hasFitted = true;
    sendResize();
  });
}
```

## Touch Interaction

### Scroll Detection (lines 449-466)

```javascript
// Determine scroll direction after 8px movement
if (isVerticalScroll === null) {
  if (Math.abs(dy) > 8 && Math.abs(dy) > Math.abs(dx) + 4) {
    isVerticalScroll = true;
  } else if (Math.abs(dx) > 8 && Math.abs(dx) > Math.abs(dy) + 4) {
    isVerticalScroll = false;
  }
}

// Send scroll events to tmux (SGR mouse protocol)
const lines = Math.max(1, Math.ceil(Math.abs(delta) / 14));
for (let i = 0; i < lines; i++) sendScroll(delta, x, y);
```

### Mouse Wheel Protocol (lines 338-351)

Converts scroll events to SGR (Select Graphic Rendition) mouse protocol for tmux/vim:

```javascript
function sendScroll(deltaY, clientX, clientY) {
  const col = clamp(Math.floor(relX / cell.width) + 1, 1, term.cols);
  const row = clamp(Math.floor(relY / cell.height) + 1, 1, term.rows);
  const btn = deltaY < 0 ? 64 : 65; // 64=scroll up, 65=scroll down
  const esc = String.fromCharCode(27);
  socket.send(JSON.stringify({ 
    type: 'input', 
    data: esc + '[<' + btn + ';' + col + ';' + row + 'M' 
  }));
}
```

## State Management

### Keyboard Visibility (lines 554-600)

```typescript
// Track keyboard visibility
const [keyboardOffset, setKeyboardOffset] = useState(0);

// Listen for keyboard events
useEffect(() => {
  const show = Keyboard.addListener('keyboardDidShow', (e) => 
    setKeyboardOffset(e.endCoordinates.height));
  const hide = Keyboard.addListener('keyboardDidHide', () => 
    setKeyboardOffset(0));
  return () => { show.remove(); hide.remove(); };
}, []);

// Auto-focus terminal when keyboard appears
useEffect(() => {
  if (appState !== 'active' || !currentSessionName) return;
  const ref = webRefs.current[currentSessionName];
  if (ref && keyboardOffset > 0) {
    ref.injectJavaScript('window.__focusTerminal && window.__focusTerminal(); true;');
  }
}, [appState, currentSessionName, keyboardOffset]);
```

### Session Tracking (lines 704-716)

```typescript
// Navigate back if all sessions were killed
const hadSessionsRef = useRef(false);

useEffect(() => {
  if (sessions.length > 0) {
    hadSessionsRef.current = true;
  }
  if (sessions.length === 0 && hadSessionsRef.current) {
    router.back();
    return;
  }
  // ... session name updates
}, [sessions, currentSessionName, router]);
```

## Styling System

**Styles created with theme colors (lines 1007-1124):**

```typescript
function createStyles(colors: ThemeColors): TerminalStyles {
  return StyleSheet.create<TerminalStyles>({
    header: { /* Floating header at top */ },
    headerFloating: { /* Rounded background */ },
    headerButton: { /* Individual buttons */ },
    pager: { /* Container for all sessions */ },
    page: { /* Individual session page */ },
    terminal: { /* Terminal container */ },
    webview: { /* WebView styles */ },
    helperOverlay: { /* Accessory bar container */ },
    helperBar: { /* Main accessory bar */ },
    helperKey: { /* Individual helper keys */ },
    expandedRow: { /* Second row for expanded state */ },
    // ...
  });
}
```

**Dynamic positioning:**
- Header: Absolute positioned at top (z-index: 10)
- Pages: Absolutely positioned at `left: index * screenWidth`
- Keyboard accessory: Positioned at `bottom: keyboardOffset`
- Terminal padding: Adjusts for `keyboardInset + helperHeight`

## Dependencies

### External Libraries

| Library | Purpose | Usage |
|---------|---------|-------|
| `xterm` | Terminal emulation | Loaded via CDN in WebView |
| `xterm-addon-fit` | Auto-resize terminal | Fits terminal to WebView size |
| `react-native-webview` | WebView component | Hosts terminal HTML |
| `react-native-gesture-handler` | Pan gestures | Session swiping |
| `react-native-reanimated` | Animations | Smooth paging transitions |
| `expo-haptics` | Haptic feedback | Touch feedback |
| `expo-clipboard` | Clipboard access | Copy/paste operations |
| `expo-image-picker` | Image selection | Upload images to server |
| `lucide-react-native` | Icons | UI icons |

### Internal Dependencies

| Import | Purpose |
|--------|---------|
| `@/components/Screen` | Base screen wrapper |
| `@/components/AppText` | Themed text component |
| `@/lib/store` | Host configuration store |
| `@/lib/snippets-store` | User snippets for accessory bar |
| `@/lib/useTheme` | Theme colors |
| `@/lib/live` | Live session updates |
| `@/lib/api` | Image upload API |

## Keyboard Accessory Bar Deep Dive

### Layout Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â†“] [Esc] [Tab] [â†‘] [â†“] [â†] [â†’] [â€¢â€¢â€¢]              â”‚ â† Main Row
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [ğŸ“‹] [ğŸ–¼] [PgUp] [PgDn] [Snippet1] [Snippet2] ... â”‚ â† Expanded Row
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Expand/Collapse Logic

```typescript
// Lines 937-941: Expand button
<Pressable
  style={({ pressed }) => [
    isAccessoryExpanded ? styles.doneKey : styles.helperKey,
    pressed && styles.keyPressed
  ]}
  onPress={() => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setIsAccessoryExpanded(!isAccessoryExpanded);
  }}
>
  {isAccessoryExpanded 
    ? <X size={16} color={colors.terminalForeground} />
    : <MoreHorizontal size={16} color={colors.terminalForeground} />
  }
</Pressable>
```

**Expanded row conditional rendering (line 943):**
```typescript
{isAccessoryExpanded && (
  <ScrollView
    horizontal
    style={styles.expandedRow}
    contentContainerStyle={styles.helperContent}
  >
    {/* Paste, Image, PgUp/Dn, Snippets */}
  </ScrollView>
)}
```

### Key Features

1. **Horizontal scrolling** - Both rows use `ScrollView horizontal` for unlimited keys
2. **Haptic feedback** - Every key press triggers light haptic
3. **Dynamic snippets** - User snippets loaded from `useSnippets()` hook (line 980-988)
4. **Visual states** - Different styles for regular keys vs. action keys (Done, Expand)
5. **Auto-collapse** - Collapses when screen loses focus or app backgrounds

## Image Upload Feature

### Flow (lines 622-683)

1. User taps image icon in expanded accessory bar (line 966)
2. Platform-specific picker shown:
   - iOS: ActionSheet with "Take Photo" / "Choose Photo"
   - Android: Alert dialog
3. Image selected with base64 encoding
4. Upload via API (line 629): `uploadImage(host, base64, mimeType)`
5. Server returns path
6. Path typed into terminal with trailing space (line 630)

```typescript
const uploadPickedImage = useCallback(
  async (result: ImagePicker.ImagePickerResult) => {
    const asset = result.assets?.[0];
    const base64 = asset?.base64;
    if (result.canceled || !base64 || !host) return;
    try {
      const mimeType = asset.mimeType ?? 'image/jpeg';
      const { path } = await uploadImage(host, base64, mimeType);
      sendToTerminal(path + ' '); // Add path to terminal
    } catch (err) {
      console.error('Upload failed:', err);
    }
  },
  [host, sendToTerminal]
);
```

## Related Files

### Similar Component
**Location:** `/home/gabrielolv/Documents/Projects/ter/app/hosts/[id]/docker/[containerId]/terminal.tsx`
- Likely a similar terminal implementation for Docker containers
- Also uses `hideKeyboardAccessoryView` (line 400)

### UI Components Used
- **Screen** - `/home/gabrielolv/Documents/Projects/ter/components/Screen.tsx`
- **AppText** - `/home/gabrielolv/Documents/Projects/ter/components/AppText.tsx`

## Key Patterns & Conventions

### 1. WebView Bridge Pattern
- JavaScript injection for commands (`window.__sendToTerminal`, etc.)
- `postMessage` from WebView to React Native
- `onMessage` handler in React Native

### 2. Ref Management
```typescript
const webRefs = useRef<Record<string, WebView | null>>({});
// Access refs by session name
webRefs.current[sessionName]?.injectJavaScript('...');
```

### 3. Shared State Animation
```typescript
const offsetX = useSharedValue(0);
const currentIndexShared = useSharedValue(0);
// Used in Reanimated gestures
```

### 4. Theme Integration
```typescript
const styles = useMemo(() => createStyles(colors), [colors]);
// Recreate styles when theme changes
```

### 5. Keyboard Handling
- Track keyboard metrics directly
- Adjust layout with padding/bottom positioning
- Auto-focus/blur terminal based on keyboard state

## Potential Improvements Identified

1. **HTML Version Caching** - `TERMINAL_HTML_VERSION` constant suggests cache invalidation strategy
2. **Selection Prevention** - CSS `user-select: none` on terminal and overlay allows custom selection
3. **Microtask Batching** - Input/output buffering reduces WebSocket message overhead
4. **Rubber Band Effect** - Visual feedback at pager boundaries
5. **Session Count Tracking** - `hadSessionsRef` prevents premature navigation

## Questions Answered

### Q1: How is the terminal view structured?
**âœ“ VERIFIED**

The terminal uses a **paged WebView architecture**:
- One WebView per session, each running xterm.js
- Animated horizontal pager with gesture-based swiping
- Floating header with controls (back, copy, kill)
- Keyboard accessory bar at bottom when keyboard visible

### Q2: How is the keyboard accessory implemented?
**âœ“ VERIFIED**

Two-row expandable design:
- **Main row**: Done, Esc, Tab, arrows, expand button
- **Expanded row**: Paste, image upload, PgUp/Dn, user snippets
- Positioned above keyboard using `keyboardOffset` state
- Auto-collapses on focus loss or app background
- Helper keys send ANSI escape codes to terminal

### Q3: How does text selection and copy work?
**âœ“ VERIFIED**

Multi-stage process:
1. **Long-press detection** in WebView (400ms threshold)
2. **Cell-based selection** using xterm.js terminal buffer
3. **Multi-line selection math** for drag extension
4. **Copy on demand** via injected JavaScript
5. **Fallback behavior** copies visible viewport if no selection
6. **Haptic feedback** on selection start and copy completion

### Q4: What is the overall component architecture?
**âœ“ VERIFIED**

Layered architecture:
```
SessionTerminalScreen (React Native)
  â”œâ”€ State Management (keyboard, sessions, selection, expansion)
  â”œâ”€ WebView per Session (xterm.js + WebSocket)
  â”œâ”€ Gesture Handler (pan for swiping)
  â”œâ”€ Animation Layer (Reanimated for paging)
  â”œâ”€ Header Controls (floating)
  â””â”€ Keyboard Accessory (conditional, expandable)
```

Communication flow:
```
User Touch â†’ WebView JS â†’ postMessage â†’ React Native onMessage
React Native â†’ injectJavaScript â†’ WebView JS â†’ xterm.js/WebSocket
```

## Open Questions

1. How does the Docker terminal variant differ from session terminal?
2. What is the `useHostLive` hook implementation?
3. How are snippets stored and synchronized?
4. What additional WebSocket message types exist server-side?
5. How does the network discovery feature integrate with terminals?
